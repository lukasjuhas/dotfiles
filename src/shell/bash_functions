#!/bin/bash

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Clone a repository and install its dependencies.

clone() {

    git clone "$1" \
        || return

    cd "$(basename "${1%.*}")" \
        || return

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Check if there are dependencies to be installed.

    if [ ! -f "package.json" ]; then
        return
    fi

    # Check if the project uses Yarn.

    if [ -f "yarn.lock" ] && command -v "yarn" $> /dev/null; then
        printf "\n"
        yarn install
        return
    fi

    # If not, assume it uses npm.

    if command -v "npm" $> /dev/null; then
        printf "\n"
        npm install
    fi

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create data URI from a file.

datauri() {

    local mimeType=""

    if [ ! -f "$1" ]; then
        printf "%s is not a file.\n" "$1"
        return
    fi

    mimeType=$(file --brief --mime-type "$1")
    #               â””â”€ do not prepend the filename to the output

    if [[ $mimeType == text/* ]]; then
        mimeType="$mimeType;charset=utf-8"
    fi

    printf "data:%s;base64,%s" \
        "$mimeType" \
        "$(openssl base64 -in "$1" | tr -d "\n")"

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Delete files that match a certain pattern from the current directory.

delete-files() {
    local q="${1:-*.DS_Store}"
    find . -type f -name "$q" -ls -delete
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Execute Vim macro

evm() {

    local numberOfTimes="${*: -1}"
    local files

    if [[ "$numberOfTimes" =~ ^[0-9]+$ ]]; then
        files=("${@:1:$#-1}")
    else
        numberOfTimes="1"
        files=("$@")
    fi

    for file in "${files[@]}"; do
        printf "* %s\n" "$file"
        vim \
            -c "norm! $numberOfTimes@q" \
            -c "wq" \
            "$file"
    done

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search history.

h() {
    #           â”Œâ”€ Enable colors for pipe.
    #           â”‚  ("--color=auto" enables colors only
    #           â”‚   if the output is in the terminal.)
    grep --color=always "$*" "$HISTFILE" \
        | less --no-init --raw-control-chars
          #    â”‚         â””â”€ Display ANSI color escape sequences in raw form.
          #    â””â”€ Don't clear the screen after quitting less.
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# From the specified files, rename the files containing a date
# in the filename to only the date in the following format:
#
#    <year>-<month>-<day> <hour>.<minute>.<second>
#
# Usage examples:
#
#  * rename-files-with-date-in-name path/to/some/directory path/to/some/file ...

rename-files-with-date-in-name() (

    rename_file() (
        filePath=$(dirname "${1%/}")
        fileName=$(basename "$1")

        # The following will do transformations such as:
        #
        #   * 20200505_050505.dng => 2020-05-05 05.05.05.dng
        #   * Screenshot_20201010-101010_Something.jpg => 2020-10-10 10-10-10.jpg
        #   * signal-2020-05-06-07-08-09-123.mp4 => 2020-05-06 07-08-09.mp4

        newFilePath="${filePath}/$(printf "%s" "$fileName" | sed 's/[^0-9]*\([0-9]\{4\}\)[_-]\{0,1\}\([0-9]\{2\}\)[_-]\{0,1\}\([0-9]\{2\}\)[_-]+\{0,1\}\([0-9]\{2\}\)[_-]\{0,1\}\([0-9]\{2\}\)[_-]\{0,1\}\([0-9]\{2\}\).*\(\..*\)$/\1-\2-\3 \4.\5.\6\7/')"

        if [ "$newFilePath" != "$1" ]; then
           printf "%s => %s\n" "$1" "$newFilePath"
           mv -f "$1" "$newFilePath"
        fi
    )

    #                 â”Œâ”€ Default to the current directory.
    for filePath in "${@:-.}"; do
        if [ -d "$filePath" ]; then
            find "${filePath%/}" \
                -type f \
                -depth 1 \
                -print \
            | while read -r f; do
                rename_file "$f"
            done
        elif [ -f "$filePath" ]; then
            rename_file "$filePath"
        fi
    done

)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Resize image.
#
# Create a new image based on the specified image resized by the
# specified amount.
#
# $1: Path to the original image.
# $2: Resize value (default is 50%).
#     See also: https://imagemagick.org/script/command-line-processing.php#geometry
#
# Usage examples:
#
#   * resize-image ./path/to/image.jpg 30%
#   * resize-image ./path/to/image.jpg 1000x1000!

resize-image() {

    # Check if ImageMagick's convert command-line tool is installed.

    if ! command -v "convert" $> /dev/null; then
        printf "ImageMagick's 'convert' command-line tool is not installed!"
        exit
    fi

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    declare path="$(dirname "$1")"
    declare fileName="$(basename "$1")"
    declare geometry="${2:-50%}"

    convert \
        "$1" \
        -colorspace RGB \
        +sigmoidal-contrast 11.6933 \
        -define filter:filter=Sinc \
        -define filter:window=Jinc \
        -define filter:lobes=3 \
        -sigmoidal-contrast 11.6933 \
        -colorspace sRGB \
        -background transparent \
        -gravity center \
        -resize "$geometry" \
        +append \
        "$path/_$fileName" \
    && printf "* %s (%s)\n" \
            "$path/_$fileName" \
            "$geometry"

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search for text within the current directory.

s() {
    grep --color=always "$*" \
         --exclude-dir=".git" \
         --exclude-dir="node_modules" \
         --ignore-case \
         --recursive \
         . \
        | less --no-init --raw-control-chars
          #    â”‚         â””â”€ Display ANSI color escape sequences in raw form.
          #    â””â”€ Don't clear the screen after quitting less.
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
    local tmpFile="${@%/}.tar";
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

    size=$(
        stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
        stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
    );

    local cmd="";
    if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
        # the .tar file is smaller than 50 MB and Zopfli is available; use it
        cmd="zopfli";
    else
        if hash pigz 2> /dev/null; then
            cmd="pigz";
        else
            cmd="gzip";
        fi;
    fi;

    echo "Compressing .tar using \`${cmd}\`â€¦";
    "${cmd}" -v "${tmpFile}" || return 1;
    [ -f "${tmpFile}" ] && rm "${tmpFile}";
    echo "${tmpFile}.gz created successfully.";
}

# Make directory and enter it
function mkd() {
    mkdir -p "$@" && cd "$@"
}

# Determine size of a file or total size of a directory
function fs() {
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh;
    else
        local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@";
    else
        du $arg .[^.]* ./*;
    fi;
}

# Create a git.io short URL
function gitio() {
    if [ -z "${1}" -o -z "${2}" ]; then
        echo "Usage: \`gitio slug url\`";
        return 1;
    fi;
    curl -i http://git.io/ -F "url=${2}" -F "code=${1}";
}

# whois a domain or a URL
function whois() {
    local domain=$(echo "$1" | awk -F/ '{print $3}') # get domain from URL
    if [ -z $domain ] ; then
        domain=$1
    fi
    echo "Getting whois record for: $domain â€¦"

    # avoid recursion
                    # this is the best whois server
                                                    # strip extra fluff
    /usr/bin/whois -h whois.internic.net $domain | sed '/NOTICE:/q'
}

# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
    if [ -f "$1" ] ; then
        local filename=$(basename "$1")
        local foldername="${filename%%.*}"
        local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
        local didfolderexist=false
        if [ -d "$foldername" ]; then
            didfolderexist=true
            read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                return
            fi
        fi
        mkdir -p "$foldername" && cd "$foldername"
        case $1 in
            *.tar.bz2) tar xjf "$fullpath" ;;
            *.tar.gz) tar xzf "$fullpath" ;;
            *.tar.xz) tar Jxvf "$fullpath" ;;
            *.tar.Z) tar xzf "$fullpath" ;;
            *.tar) tar xf "$fullpath" ;;
            *.taz) tar xzf "$fullpath" ;;
            *.tb2) tar xjf "$fullpath" ;;
            *.tbz) tar xjf "$fullpath" ;;
            *.tbz2) tar xjf "$fullpath" ;;
            *.tgz) tar xzf "$fullpath" ;;
            *.txz) tar Jxvf "$fullpath" ;;
            *.zip) unzip "$fullpath" ;;
            *) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# who is using the laptop's iSight camera?
camerausedby() {
    echo "Checking to see who is using the iSight cameraâ€¦ ðŸ“·"
    usedby=$(lsof | grep -w "AppleCamera\|USBVDC\|iSight" | awk '{printf $2"\n"}' | xargs ps)
    echo -e "Recent camera uses:\n$usedby"
}

# backup files from a docker volume into /tmp/backup.tar.gz
# e.g. docker-volume-backup-compressed development_mysql_data
function docker-volume-backup-compressed() {
    docker run -v "$1:/volume" -v /tmp:/backup --rm loomchild/volume-backup backup "$1_volume_backup"
}
# restore files from /tmp/backup.tar.gz into a docker volume
function docker-volume-restore-compressed() {
    docker run -v $1:/volume -v /tmp:/backup --rm loomchild/volume-backup restore "$1_volume_backup"
}